{"version":3,"sources":["AnimationManager.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"AnimationManager-compiled.js","sourcesContent":["// import Utilities from '../../utilites';\n// import Scene from '../ui/Scene'\n//\n// export default class AnimationManager {\n//     constructor(config) {\n//         let me = this;\n//\n//         //set up a canvas list\n//         me.canvasList = {};\n//\n//         me.initWebGL(config);\n//\n//         me.animationBuffer = [];\n//\n//         me.currentTime = 0;\n//         me.timeFromStart = 0;\n//\n//         me.paused = false;\n//\n//         me.currentStepTime = 0;\n//\n//         me.setupImages(config.images);\n//\n//         me.setupScenes(config.scenes);\n//\n//         me.renderLoopEndEvents = [];\n//\n//         me.isRunning = false;\n//\n//         me.sprites = config.images.sprites;\n//\n//         // Select which render function to use\n//         me.selectRenderFunction();\n//     }\n//\n//     /**\n//      * Starts the animation for the given queue\n//      *\n//      * @param {String} sceneName Name of the scene to start\n//      */\n//     start (sceneName) {\n//         var me = this;\n//\n//         // Switch current scene\n//         me.currentScene = sceneName;\n//\n//         me.isRunning = true;\n//\n//         me.currentTime = 0;           // Time since the animation started\n//         me.lastTimeStepOccured = Date.now();   // The time of last time step render\n//         me.paused = false;\n//\n//         me.scenes[me.currentScene].lists.sort(function (a, b) {\n//             return a.prop.depth - b.prop.depth;\n//         });\n//\n//         me.requestNextAnimationStep();\n//     }\n//\n//     /**\n//      *\n//      * @param sceneName\n//      */\n//     switchScenes(sceneName) {\n//         this.currentScene = sceneName;\n//     }\n//\n//     /**\n//      * Removes all the scenes from the specified scene\n//      * @param {String} sceneName The scene to be cleared\n//      */\n//     clearScene(sceneName) {\n//         if (typeof sceneName !== \"undefined\") {\n//             this.scenes[sceneName].lists = [];\n//         }\n//     }\n//\n//     addToRenderLoop(list, sceneName) {\n//         var me = this,\n//             targetScene = typeof sceneName !== \"undefined\" ? sceneName : this.currentScene;\n//\n//         if (list.id !== \"reelsMainList\"){\n//             console.error(\"change list to Container and use addPixiToRenderLoop\")\n//         }\n//\n//         // Make sure that the list does not already exist in the scene\n//         if (!me.isInScene(list, targetScene)) {\n//             me.scenes[targetScene].lists.push(list);\n//\n//             list.pixiItem.listDepth = me.getListDepth(list);\n//             if (list.pixiItem.listDepth >= 0) {\n//                 me.addAndSort(list.pixiItem);\n//             }\n//         }\n//         // If it does make sure that it is running\n//         else {\n//             list.prop.running = true;\n//         }\n//     }\n//\n//     addAndSort(item) {\n//         var me = this;\n//\n//         me.rootDisplayObject.addChild(item);\n//         me.rootDisplayObject.children.sort(function (a, b) {\n//             return a.listDepth - b.listDepth;\n//         })\n//     }\n//\n//     getListDepth(item) {\n//         var me = this,\n//             depth;\n//\n//         depth = zIndeces.indexOf(item.id);\n//         if (depth < 0) {\n//             console.error(\"Invalid depth of list \" + item.id);\n//         }\n//         return depth;\n//     }\n//\n//     addPixiToRenderLoop(item) {\n//         var me = this;\n//         item.listDepth = me.getListDepth(item);\n//         if (item.listDepth >= 0) {\n//             me.addAndSort(item);\n//         }\n//     }\n//\n//     /**\n//      * Check if the provided list is present in the provided scene.\n//      *\n//      * @param {Animation.CanvasAnimationList} list The list to check for\n//      * @param {String} scene The name of the scene\n//      * @return {Boolean} True if it is already there and false other\n//      */\n//     isInScene(list, scene) {\n//         var targetScene = Utilities.isDefined(scene) ? scene : this.currentScene,\n//             sceneObj = this.scenes[targetScene];\n//\n//         return (sceneObj.lists.contains(list) || sceneObj.listsToAdd.contains(list) || sceneObj.nonActiveLists.contains(list));\n//     }\n//\n//     /**\n//      * Check if the manager is running render loop\n//      */\n//     isRunningRendering() {\n//         return this.isRunning;\n//     }\n//\n//     /**\n//      * Removes the specified list from the current scene\n//      *\n//      * @param {Animation.CanvasAnimationList} list The list to remove\n//      * @param {String} [scene] The list to remove\n//      */\n//     removeList(list, scene) {\n//         var me = this,\n//             sceneToUse = Utilities.isDefined(scene) ? scene : me.currentScene,\n//             currentScene = me.scenes[sceneToUse],\n//             activeIndex = currentScene.lists.indexOf(list),\n//             toAddIndex = currentScene.listsToAdd.indexOf(list),\n//             nonActiveIndex = currentScene.nonActiveLists.indexOf(list);\n//\n//         // Remove it if it is in the lists array\n//         if (activeIndex > -1) {\n//             currentScene.lists[activeIndex].prop.running = false;\n//         }\n//         else if (nonActiveIndex > -1) {\n//             currentScene.nonActiveLists[nonActiveIndex].prop.running = false;\n//         }\n//         else if (toAddIndex > -1) {\n//             currentScene.listsToAdd.splice(toAddIndex, 1);\n//         }\n//     }\n//\n//\n//     /**\n//      * Pause the animation\n//      */\n//     pauseAnimation() {\n//         this.paused = true;\n//\n//         clearTimeout(this.renderTimeout);\n//     }\n//\n//     /**\n//      * Start the animation again\n//      */\n//     continueAnimation() {\n//         this.paused = false;\n//\n//         this.run();\n//     }\n//\n//     /**\n//      * Returns the sprite index for the specified sprite\n//      *\n//      * @param {String} name The name of the sprite sequence to get\n//      * @return {Array} An array of sprite frames\n//      */\n//     getSpriteSequence(name) {\n//         return this.sprites[name];\n//     }\n//\n//     /**\n//      *\n//      * @param imagesToAdd\n//      */\n//     addImages(imagesToAdd) {\n//         Utilities.apply(this.images, imagesToAdd);\n//     }\n//\n//     /**\n//      *\n//      * @return {boolean}\n//      */\n//     shouldRenderNextFrame() {\n//         return (!this.paused);\n//     }\n//\n//\n//     /**\n//      * @private\n//      *\n//      */\n//     run() {\n//         var me = this;\n//         me.stats.begin();\n//\n//         me.renderLoopEndEvents.length = 0;\n//\n//         me.calculate();\n//         me.animate();\n//\n//         me.renderer.render(me.stage);\n//\n//         if (me.renderLoopEndEvents.length > 0) {\n//             me.fireLoopEndEvents();\n//         }\n//\n//         // If we are allowed to draw another time step, do so\n//         if (me.shouldRenderNextFrame()) {\n//             me.lastTimeStepOccured = me.updateTime();\n//\n//             // Request next animation step\n//             me.requestNextAnimationStep();\n//         } else {\n//             me.isRunning = false;\n//         }\n//\n//         me.stats.end();\n//     }\n//\n//     /**\n//      * @private\n//      * Will fire all the events collected in the last render loop\n//      */\n//     fireLoopEndEvents() {\n//         var me = this,\n//             numItems = me.renderLoopEndEvents.length,\n//             i, eventObj;\n//\n//         for (i = -1; ++i < numItems;) {\n//             eventObj = me.renderLoopEndEvents[i];\n//\n//             eventObj.scope.fireEvent(eventObj.event, eventObj.argument);\n//         }\n//     }\n//\n//     /**\n//      * @private\n//      * Runs the animation loop one time step\n//      */\n//     calculate() {\n//         var me = this,\n//             name, filtersArray, i,\n//             sceneToRun = this.scenes[this.currentScene];\n//\n//         if (typeof sceneToRun !== \"undefined\") {\n//\n//             // Run the scene\n//             sceneToRun.run({\n//                 timeStep: me.currentStepTime,\n//                 time: me.currentTime\n//             });\n//\n//             //UPDATE SHADERS UNIFORMS\n//             // for(name in FiltersNS){\n//             //     filtersArray = FiltersNS[name];\n//             //\n//             //     if(filtersArray instanceof Array && filtersArray.length > 0){\n//             //         for(i=0;i<filtersArray.length;i++){\n//             //             filtersArray[i].updateUniforms({\n//             //                 timeStep: me.currentStepTime,\n//             //                 time: me.currentTime\n//             //             });\n//             //         }\n//             //     }\n//             // }\n//\n//         } else {\n//             console.error(\"CanvasAnimationManager:calculate - currentScene '\" + sceneToRun + \"' could not be found\");\n//         }\n//     }\n//\n//     /**\n//      * @private\n//      * Signals the manager that the next animation step should be rendered\n//      */\n//     requestNextAnimationStep() {\n//         var me = this;\n//\n//         me.animationFunction.call(window, function () {\n//             me.run();\n//         });\n//     }\n//\n//     /**\n//      * @private\n//      *\n//      * @return {number}\n//      */\n//     updateTime() {\n//         var me = this,\n//             now = Date.now(),\n//             diff = now - me.lastTimeStepOccured;\n//\n//         // Check if more time than allowed has passed since the last frame\n//         if (diff > 250) {\n//             diff = 1000 / 60;\n//         }\n//\n//         me.currentStepTime = diff | 0;\n//\n//         me.currentTime += me.currentStepTime;\n//\n//         return now;\n//     }\n//\n//     /**\n//      * @private\n//      * Select which render function to use\n//      */\n//     selectRenderFunction() {\n//         var me = this;\n//\n//         this.animationFunction = window.requestAnimationFrame ||\n//             window.webkitRequestAnimationFrame ||\n//             window.mozRequestAnimationFrame ||\n//             window.oRequestAnimationFrame ||\n//             window.msRequestAnimationFrame ||\n//             function (callback) {\n//                 clearTimeout(me.renderTimeout);\n//                 me.renderTimeout = setTimeout(callback, Math.round(1000 / 60));\n//             };\n//     }\n//\n//     /**\n//      * @private\n//      *\n//      * @param extraScenes\n//      */\n//     setupScenes(extraScenes) {\n//         var sceneCfg = Utilities.isDefined(extraScenes) ? extraScenes : [],\n//             scenes = {};\n//\n//         sceneCfg.push(\"base\");\n//\n//         for (let i of sceneCfg){\n//             scenes[i] = new Scene({});\n//         }\n//\n//         this.scenes = scenes;\n//         this.scenes.base.play();\n//         this.currentScene = \"base\";\n//     }\n//\n//     setupImages(config) {\n//         let me = this,\n//             rawImages = Utilities.isDefined(config.files) ? config.files : config,\n//             // images = Resources.readData(\"animationImages\") || {},\n//             // spines = Resources.readData(\"spines\") || {},\n//             // bitmapFonts = Resources.readData(\"bitmapFonts\") || {},\n//             spriteConfigurations = Resources.readData(\"spriteConfigurations\") || {},\n//             assetsToLoader = [];\n//\n//         // me.imageReadyEvent = readyEvent;\n//         me.imagesRemaining = [];\n//         me.remainingImages = 0;\n//\n//         Sys.iterate(rawImages, function (imageName, imageSrc) {\n//             assetsToLoader.push({name: imageName, src: imageSrc});\n//         });\n//\n//         // if (Sys.isDefined(config.spineConfigurations)) {\n//         //     Sys.iterate(config.spineConfigurations, function (spineName, JSONPath) {\n//         //         assetsToLoader.push({name: spineName, src: JSONPath});\n//         //         spines[spineName] = JSONPath;\n//         //     });\n//         //\n//         // }\n//\n//         // if (Sys.isDefined(config.bitmapFontConfigurations)) {\n//         //     Sys.iterate(config.bitmapFontConfigurations, function (bitmapFontName, fntSrc) {\n//         //         assetsToLoader.push({name: bitmapFontName, src: fntSrc});\n//         //         bitmapFonts[bitmapFontName] = fntSrc;\n//         //     });\n//         //     Resources.storeData(\"bitmapFonts\", bitmapFonts);\n//         // }\n//\n//         me.loader = PIXI.loader;\n//         me.loader.once('complete', function (loader, res) {\n//             Sys.iterate(rawImages, function (imageName, imageSrc) {\n//                 images[imageName] = PIXI.Texture.fromImage(imageSrc);\n//             });\n//\n//             // Sys.iterate(config.spineConfigurations, function (spineName, spineSrc) {\n//             //     spines[spineName] = res[spineName].spineData;\n//             // });\n//             // Resources.storeData(\"spines\", spines);\n//\n//             me.images = images;\n//             // Resources.storeData(\"animationImages\", images);\n//\n//             // me.processSprites(me.imageReadyEvent);\n//         });\n//\n//\n//         for (var i = 0; i < assetsToLoader.length; i++) {\n//             me.loader.add(assetsToLoader[i].name, assetsToLoader[i].src);\n//         }\n//         me.loader.load();\n//\n//\n//         if (Sys.isDefined(config.spriteConfigurations)) {\n//             Sys.iterate(config.spriteConfigurations, function (spriteName, configuration) {\n//                 spriteConfigurations[spriteName] = configuration;\n//             });\n//         }\n//         me.spriteConfigurations = spriteConfigurations;\n//         Resources.storeData(\"spriteConfigurations\", spriteConfigurations);\n//     }\n//\n//     processSprites(readyEvent) {\n//         var me = this;\n//\n//         for (var key in me.sprites) if (me.sprites.hasOwnProperty(key)){\n//             me.sprites[key].frames = me.getFramesFromSpriteSheet(me.sprites[key]);\n//         }\n//         Resources.storeData(\"sprites\", me.sprites);\n//         me.fireEvent(readyEvent);\n//     }\n//\n//     getFramesFromSpriteSheet(config) {\n//         var frames = [],\n//             texture = this.images[config.texture],\n//             fw = config.frameWidth, fh = config.frameHeight;\n//\n//         if (!Sys.isDefined(texture)) {\n//             console.error(\"Spritesheet texture: \" + config.texture + \"is not found\");\n//             return;\n//         }\n//\n//         for (var i = 0; i <= texture.height - fh; i += fh) {\n//             for(var j = 0; j <= texture.width - fw; j += fw) {\n//                 frames.push(new PIXI.Texture(texture.baseTexture, new PIXI.Rectangle(j, i, fw, fh)));\n//             }\n//         }\n//         return frames;\n//     }\n//\n//     //------------------------------------------------------------\n//     // PIXI NEW FUNCTIONS\n//     //------------------------------------------------------------\n//     onResize() {\n//         var me = this,\n//             scaleValue = Environment.getVirtualToWindowScale(3);\n//         me.rootDisplayObject.scale = new PIXI.Point(scaleValue, scaleValue);\n//\n//     }\n//\n//     initWebGL(config) {\n//         let me = this,\n//             stage = new PIXI.Container(),\n//             renderer,\n//             renderDisplay = \"Error\";\n//\n//             renderer = PIXI.autoDetectRenderer(config.width, config.height, {antialias: true, resolution: 1});\n//             renderDisplay = \"Auto - \";\n//             if (Utilities.isDefined(renderer.filterManager)) {\n//                 renderDisplay += \"WebGL\";\n//             }\n//             else {\n//                 renderDisplay += \"Canvas\";\n//             }\n//\n//         // var queryData = Resources.readData(\"queryData\");\n//         // var forceCanvasRendering = queryData.forcecanvasrendering;\n//\n//         // if (Utilities.isDefined(forceCanvasRendering) && forceCanvasRendering === true) {\n//         //     renderer = new PIXI.CanvasRenderer(config.width, config.height, {antialias: false, resolution: 1});\n//         //     renderDisplay = \"Canvas\";\n//         // }\n//         // else {\n//         //     renderer = PIXI.autoDetectRenderer(config.width, config.height, {antialias: true, resolution: 1});\n//         //     renderDisplay = \"Auto - \";\n//         //     if (Utilities.isDefined(renderer.filterManager)) {\n//         //         renderDisplay += \"WebGL\";\n//         //     }\n//         //     else {\n//         //         renderDisplay += \"Canvas\";\n//         //     }\n//         //\n//         // }\n//         //\n//         // if (Environment.platform === \"mobileLow\") {\n//         //     renderer = new PIXI.CanvasRenderer(config.width, config.height, {antialias: false, resolution: 1});\n//         //     renderDisplay = \"Canvas\";\n//         // }\n//         // else {\n//         //     renderer = PIXI.autoDetectRenderer(config.width, config.height, {antialias: false, resolution: 1});\n//         //     renderDisplay = \"Auto - \";\n//         //     if (Sys.isDefined(renderer.filterManager)) {\n//         //         renderDisplay += \"WebGL\";\n//         //     }\n//         // }\n//\n//         renderer.view.id = \"canvasAnimationManager\";\n//         config.parent.appendChild(renderer.view);\n//\n//         me.stage = stage;\n//         me.rootDisplayObject = new PIXI.Container();\n//         me.stage.addChild(me.rootDisplayObject);\n//         me.renderer = renderer;\n//\n//\n//         me.setupStats(config, renderDisplay);\n//         me.onResize();\n//     }\n//\n//     //@TODO remove stats before release\n//     setupStats(config, renderDisplay) {\n//         var me = this;\n//         me.stats = new Stats();\n//         config.parent.appendChild(me.stats.domElement);\n//         me.stats.domElement.style.position = \"absolute\";\n//         me.stats.domElement.style.top = '17px';\n//         me.stats.domElement.style.left = '24px';\n//         me.stats.domElement.style.webkitTransform = \"scale(1.5)\";\n//         me.stats.addLogElement(\"renderer\", renderDisplay);\n//         // me.stats.domElement.hidden = true;\n//     }\n//\n//     animate () {\n//         var me = this;\n//\n//         me.animationBuffer.forEach(function (item) {\n//             if (item.running) {\n//                 item.run({\n//                     timeStep: me.currentStepTime,\n//                     time: me.currentTime\n//                 });\n//             }\n//         });\n//     }\n//\n//     addAnimationItem(item) {\n//         var me = this,\n//             index = me.animationBuffer.indexOf(item);\n//\n//         if (index === -1) {\n//             this.animationBuffer.push(item);\n//         }\n//     }\n//\n//     removeAnimationItem(item) {\n//         var me = this,\n//             index = me.animationBuffer.indexOf(item);\n//\n//         if (index > -1) {\n//             me.animationBuffer.splice(index, 1);\n//         }\n//     }\n// }"]}